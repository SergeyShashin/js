<script>

  const puzzle = [
    'ANGULAR',
    'REDNCAE',
    'RFIDTCL',
    'AGNEGSA',
    'YTIRTSP'
  ];

  console.log(findWord(puzzle, 'ANGULAR')); //true
  console.log(findWord(puzzle, 'REACT')); //true 
  console.log(findWord(puzzle, 'ARRAY')); //true
  console.log(findWord(puzzle, 'UNDEFINED')); //true
  console.log(findWord(puzzle, 'RED')); //true
  console.log(findWord(puzzle, 'STRING')); //true
  console.log(findWord(puzzle, 'CLASS')); //true
  console.log(findWord(puzzle, 'FUNCTION')); //false
  console.log(findWord(puzzle, 'NULL')); //false


  /*
  Возвращает true, если в puzzle можно собрать слово word. В остальных случаях false.
  Перемещаться можно по вертикали или горизонтали. Нарушть границы нельзя. Буквы из puzzle можно использовать только 1 раз.
  */
  function findWord(puzzle, word) {
    let result = true;
    const alphabet = englishAlphabet();
    let lengthStr = puzzle[0].length;

    //собираем объект с индексами букв puzzle
    puzzle.map((row, idxRow) => {
      row.split('').map((col, idxCol) => {
        alphabet[col].push({ row: idxRow, col: idxCol });
      })
    })


    word.split('').map((char, idxChar) => {
      if (alphabet[char] && word[idxChar + 1]) {

        let nextChar = word[idxChar + 1];

        if (!checkStep(alphabet[char], alphabet[nextChar], lengthStr)) {
          result = false;
          return
        }

        // проверка возможности наличия пути из последнего символа word в предпоследний
      } else if (word[idxChar]) {

        let prevChar = word[idxChar - 1];

        let lastChar = word[idxChar];

        if (!checkStep(alphabet[prevChar], alphabet[lastChar], lengthStr)) {
          result = false;
          return
        }

      }
      else {
        result = false;
        return
      }

    });

    return result
  }

  /*
  Создаёт объект с английскими буквами
  */
  function englishAlphabet() {
    const alphabet = {};

    for (let i = 65; i < 91; i++) {
      alphabet[String.fromCharCode(i)] = [];
    }

    return alphabet
  }

  /*
  Возращает true, если можно шагнуть к следующей букве и false, если нельзя 
  */
  function checkStep(coordinatesChar, coordinatesNextChar, lengthStr) {

    let isStepLeft;
    let isStepRight;
    let isStepTop;
    let isStepBottom;

    for (let coordinateNextChar of coordinatesNextChar) {

      let nextCol = coordinateNextChar.col;

      let nextRow = coordinateNextChar.row;

      //проверяем возможность шага влево
      if (nextCol - 1 >= 0) {
        if (checkStepLeftOrRight(coordinatesChar, nextCol - 1, coordinateNextChar.row)) {
          isStepLeft = true;
        };
      }

      //проверяем возможность шага вправо
      if (nextCol + 1 <= lengthStr) {
        if (checkStepLeftOrRight(coordinatesChar, nextCol + 1, coordinateNextChar.row)) {
          isStepRight = true;
        };
      }

      //проверяем возможность шага вверх
      if (nextRow - 1 >= 0) {
        if (checkStepTopOrBottom(coordinatesChar, nextRow - 1, coordinateNextChar.col)) {
          isStepTop = true;
        };
      }

      //проверяем возможность шага вниз
      if (nextRow + 1 <= lengthStr) {
        if (checkStepTopOrBottom(coordinatesChar, nextRow + 1, coordinateNextChar.col)) {
          isStepBottom = true;
        };
      }

    }

    return isStepLeft || isStepRight || isStepTop || isStepBottom;
  }

  /*
  Возвращает true если шаг влево или вправо воможен
  */
  function checkStepLeftOrRight(coordinatesChar, col, row) {

    for (let coordinateChar of coordinatesChar) {

      if (coordinateChar.col === col && coordinateChar.row === row) {
        return true
      }

    }

  }

  /*
  Возвращает true если шаг вверх или вниз возможен
  */
  function checkStepTopOrBottom(coordinatesChar, row, col) {

    for (let coordinateChar of coordinatesChar) {

      if (coordinateChar.row === row && coordinateChar.col === col) {
        return true
      }

    }

  }


</script>